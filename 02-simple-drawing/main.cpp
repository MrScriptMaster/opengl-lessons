
/* 
 * Пример основан на упражнении: Hello-Triangle (https://learnopengl.com/Getting-started/Hello-Triangle)
 * 
 * Конвейер
 * -----------------------
 * В этом примере мы нарисуем несколько треугольников, чтобы понять как устроен конвейер OpenGL.
 * 
 * Прежде чем что либо нарисовать на экране, драйвер графической карты должен проделать много однотипной работы в конвейере.
 * В конвейер входит 6 этапов:
 * 1. Исполнение шейдера вершин - на этом этапе на вход конвейера поступают координаты вершин. Небольшая программа, которая называется шейдером вершин, переводит их условные координаты в физические координаты на экране или, другими словами, в пиксели.
 * 2. Построитель примитивов - преобразованные вершины соединяются линиями. Обычно сложные фигуры строятся из простых, таких как треугольники. Эти простые фигуры называются "примитивами". Говоря просто, на этом этапе вершины соединяются линиями по некоторому правилу.
 * 3. Геометрический шейдер - на этом этапе из уже построенных примитивов строятся новые, в зависимости от программы, написанной разработчиком.
 * 4. Растеризация - на этом этапе фигуры превращаются во фрагменты или массив из пикселей. У каждого пикселя во фрагменте есть свой набор атрибутов. Также на этом этапе выпоняется вырезка фрагментов (clipping), т.е. отбрасываются те фрагменты, которые при данном наблюдении не видны.
 * 5. Исполнение шейдера фрагментов - на этом этапе вычисляются цвета фрагментов и могут быть применены некоторые эффекты, такие как затенение или отражение.
 * 6. Тесты и смешение - на этом этапе каждый фрагмент проходит тесты: тест глубины, чтобы понять какой фрагмент ближе к наблюдателю, а какой дальше; "стенсил тест", когда рисование происходит по трафарету; тест на прозрачность. На заключительном этапе происходит смешение цветов и реализуется окончательное изображение. В результате смешения цвет фрагмента может измениться.
 * 
 * Разработчик может изменять или конфигурировать шейдеры на 1, 3 и 5 этапах. Остальные этапы выполняются автоматически, но некоторое поведение вы можете изменять с помощью функций OpenGL.
 * 
 * В современном OpenGL разработчик должен минимум предоставить конвейеру вершинный шейдер (1 этап) и определить шейдер фрагментов (5 этап), т.к. эти части конвейера не имеют стандартной реализации.
 */
 
#include "application.h"

BEGIN_APP_DECLARATION(Triangles)
    virtual void gInit(const char* title = NULL);
    virtual void gRender(bool auto_redraw = true);
    virtual void gFinalize();
    void onKey(int key, int scancode, int action, int mods);
protected:
    unsigned int VBO, VAO, EBO; // для ссылки на буферы
    int shaderProgram;  // для ссылки на шейдеры
    int switcher;       // переключение рисования из буфера вершин или буфера элементов (нажимайте клавиши 1, 2, 3 или 4, но не на малой цифровой клавиатуре)
    int mode;           // для переключения на каркасный режим отображения   (нажимайте клавиши 8 или 9, но не на малой цифровой клавиатуре)
END_APP_DECLARATION()

DEFINE_APP(Triangles, "Triangles")

//-----------------------------------------------------
/*
 * Чтобы нарисовать что-нибудь, необходимо указать координаты контура фигуры, либо
 * узлы этой фигуры. OpenGL работает в трехмерной декартовой системе координат, поэтому
 * для каждой вершины нужно задать координаты x, y и z. При плоском рисовании следует делать
 * координату z нулевой, т.е. у сцены нет глубины.
 * 
 * Чтобы задать систему координат используется область просмотра (viewport). В OpenGL
 * положительным направлением для оси x считается слева-направо, для оси y - снизу вверх, а для оси
 * z - от заднего фона экрана к наблюдателю. Координаты следует передавать в нормализованном виде, т.е.
 * их допустимые значения лежат в промежутке от 0.0 до (+/-)1.0. Все что выходит за эти пределы считается
 * невидимым и обрезается в случае, если система координат не перемещается.
 * 
 * Началом отсчета по умолчанию является середина viewport по горизонтали, по вертикали и по глубине.
 *
 * Участок памяти на графической карте, который используется для хранения вершин, называется буферизованным
 * вершинным объектом (vertex buffer objects (VBO)). Шейдеры исполняются на процессоре графической карты,
 * поэтому они получают доступ к VBO черезвычайно быстро.
 */

/*
 * Шейдеры
 * 
 * Шейдеры составляются на языке GLSL похожий на C. Шейдеры компилируются на ходу, поэтому код шейдера
 * поставляется программе в виде строки.
 * 
 * Очень важно, чтобы аппаратная часть, для которой вы пишите программу, поддерживала выбранную вами
 * спецификацию шейдеров. В этом и последующих примерах мы будем использовать спецификацию версии 3.3.0.
 * 
 * Ниже показано два шейдера: вершинный и шейдер фрагментов. Все шейдеры должны
 * начинаться с номера версии OpenGL, для которой они поставляются.
 * 
 * Шейдеры обычно пишутся в отдельных исходных файлах. Так, как это показано в этом примере, в реальных пронетах делать
 * не следует.
 */

/*
 * Следующий вершинный шейдер демонстрирует общую структуру шейдера вообще.
 * Первая строка шейдера объявляет версию OpenGL для которой он написан. В этом примере
 * это версия 3.3.0 (330).
 * 
 * У шейдера выделяются входы и выходы. В этом шейдере всего один вход, который объявляется
 * через оператор in. В данном случае мы принимаем в виде трехмерного вектора вершину, для
 * ссылки на которую будет использоваться имя aPos. С помощью оператора layout (location = 0) мы указываем
 * место хранения вершины в буфере "буферизованных вершин". К каждой вершине будет применен этот шейдер.
 * В каком порядке вершины будут передаваться шейдеру будет показано ниже во время инициализации сцены.
 * 
 * После объявления входа начинается тело шейдера, которое оформляется в функции main. Переменная
 * gl_Position является предопределенным вектором размерности 4 (vec4), в котором первые три значения
 * указывают координату вершины, а четвертое - делитель перспективы. В данном случае перспективы нет,
 * поэтому мы должны передавать 1.0. gl_Position является выходом шейдера. В этом примере шейдер ничего
 * не делает с входной вершиной, а просто переписывает ее как есть в выходную переменную.
 */
const char* vertexShaderS = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0f);\n"
    "}\0";

/* 
 * Шейдер фрагментов также прост как и шейдер вершин. В этом примере мы объявляем выходную переменную
 * FragColor. В OpenGL цвет получается по схеме RGB, т.е. через сочетание красного, зеленого и синего
 * полутонов, где единица означает максимальный оттенок (красный, зеленый или синий). 
 * Четвертный параметр выходного текста отвечает за прозрачность, где 1 - это полностью не прозрачный.
 * 
 * В этом шейдере мы присваиваем каждой вершине одинаковый цвет (в данном случае оранжевый).
 */
const char* fragmentShaderS = "#version 330 core\n"
    "out vec4 FragColor;\n"
    "void main()\n"
    "{\n"
    "   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
    "}\n\0";

void Triangles::gInit(const char* title) {
    base::gInit(title);
    glfwSwapInterval(1);
    
    switcher = 0;
    mode = 0;
    
    // Сборка и компиляция шейдеров
    int success = 0;
    char infoLog[512];
    // Шейдер вершин
    int vShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vShader, 1, &vertexShaderS, NULL);
    glCompileShader(vShader);
    // узнаем результат компиляции шейдера
    glGetShaderiv(vShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(vShader, 512, NULL, infoLog);
        std::cout << "Shader: " << infoLog << std::endl;
        throw std::logic_error("can't compile vertex shader");
    }
    // шейдер фрагментов
    int fShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fShader, 1, &fragmentShaderS, NULL);
    glCompileShader(fShader);
    glGetShaderiv(fShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(fShader, 512, NULL, infoLog);
         std::cout << "Shader: " << infoLog << std::endl;
        throw std::logic_error("can't compile fragment shader");
    }
    // Линковка шейдеров
    shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vShader);
    glAttachShader(shaderProgram, fShader);
    glLinkProgram(shaderProgram);
    // узнаем результат линковки
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        std::cout << "Linking shaders: " << infoLog << std::endl;
        throw std::logic_error("failed shaders linking");
    }
    glDeleteShader(vShader);
    glDeleteShader(fShader);
    
    // определяем вершины для треугольников. Треугольники смежны по гипотенузе, поэтому после заливки
    // мы увидим прямоугольник. Середина этого прямоугольника совпадает с центром начала координат
    float vertices[] = {
         0.5f,  0.5f, 0.0f,  // верхний правый угол         0
         0.5f, -0.5f, 0.0f,  // нижний правый               1
        -0.5f, -0.5f, 0.0f,  // нижний левый                2
        -0.5f,  0.5f, 0.0f   // верхний левый               3
    };
    // индексы для индексного рисования
    // При индексном рисовании мы подсказываем OpenGL по индексам в каком порядке рисовать вершины, а их координаты OpenGL возьмет из буфера вершин
    // Мы используем индексы, чтобы нарисовать прямоугольник из двух треугольников по одному набору вершин
    /*
     * В этом примере для рисования двух треугольников вам нужно хранить в памяти всего 4 точки. Это прием работает,
     * потому что треугольники смежные, и мы можем сэкономить память и ускорить рисование.
     */
    unsigned int indices[] = {
        0, 1, 3,  // мы используем индексы массива vertices[], чтобы обозначить первый треугольник.
        1, 2, 3   // второй трегольник
    };
    
    /*
     * Для рисования с помощью шейдеров, необходимо выделить место в контексте для данных, по которым будет отрисовываться
     * сцена. В нашем простом примере данными являются вершины, которые были записаны в vertices[] и индексы, записанные в indices[].
     * 
     * В OpenGL есть разные буферы, используемые для различных ситуаций. В этом примере мы продемонстрируем метод рисования
     * по вершинам через функцию glDrawArrays, и по индексам с помощью glDrawElements. Все буферы в OpenGL получают уникальный
     * индекс, назначаемый программистом, по которому к ним можно обратиться.
     * 
     * Координаты вершин являются одними из многих атрибутов. Все атрибуты должны размещаться в буфере типа Vertex Array Object
     * или VAO. При рисовании по вершинам драйвер использует буфер типа GL_ARRAY_BUFFER или VBO, в который он копирует нужные ему
     * атрибуты из VAO. Каким образом вершины должны выбираться из VAO в VBO мы должны подсказать с помощью функции
     * glBufferData. Далее вы увидите как это делается. Обратите внимание, что при инициализации буферов очень важен порядок вызова
     * определенных функций. Если вы что-то пропустите или вызовите не в той последовательности, то вероятнее всего на экран ничего
     * не будет выводиться, или будет, но не так как вы ожидаете.
     * 
     * При рисовании с помощью индексов в дополнение к VAO и VBO буферам должен быть проинициализирован буфер элементов или EBO, который
     * будет хранить индексы.
     * 
     * В реальных программах на один законченный графический объект обычно приходится по одному VAO буферу. Программисту важно "объяснить" OpenGL
     * какие из них должны быть сейчас отображены и какими способами это делать.
     */    
    
    // генерируем VAO (Vertex Array Object), который будет хранить атрибуты (в данном случае координаты).
    // VAO должен ассоциироваться с VBO.
    glGenVertexArrays(1, &VAO);
    // генерируем буфер для вершин
    glGenBuffers(1, &VBO);
    // генерируем буфер для элементов
    glGenBuffers(1, &EBO);
    
    // привязывем буфер вершин. Привязка буферов VBO и EBO будет направлена на тот VAO, к которому
    // эта функция была вызвана последней.
    glBindVertexArray(VAO);
    // привязываем буфер для вершин к контексту. С каждым VBO буфером должен быть связан один VAO буфер
    /* ВАЖНО: VBO будет связан с последним VAO для которого вызван glBindVertexArray.
     * Внимательно следите за порядком вызовов. Чтобы отменить действие glBindVertexArray, вызовите его с аргументом
     * glBindVertexArray(0)
     */
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    // передаем в буфер координаты вершин и указываем стратегию их перерисовывания
    /*
     * Так как наш треугольник абсолютно статичен, мы предлагаем использвать метод его обновления
     * GL_STATIC_DRAW, чтобы оптимизировать работу аппаратной части.
     */
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // Последний привязанный VAO будет автоматически ассоциирован с этим EBO
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    /*
     * Следующей функцией мы подсказываем OpenGL как нужно читать поток из входных
     * вершин:
     *  - первый аргумент - где размещать вершины. Этот 0 соотносится со строкой layout (location = 0)
     *    в шейдере вершин
     *  - второй аргумент - сколько элементов массива нужно записать в один вектор. В шейдере используется
     *    vec3 поэтому мы записываем 3.
     *  - третий аргумент - какой тип данных используется в векторе. Здесь это GL_FLOAT.
     *  - четвертый аргумент - нужно ли нормировать значения вершин. Мы устанавливаем GL_FALSE, потому
     *    что вершины передаются в уже нормированном виде.
     *  - пятый аргумент - это шаг (stride). После того как одна вершина обработана в массиве, мы говорим на сколько 
     *    нужно элементов массива шагнуть, чтобы начать интерпретировать новую вершину. В данном случае
     *    3*sizeof(float) байт.
     *  - шестой аргумент - это смещение, чтобы показать с какой позиции начинаются вершины в VBO.
     *    В этом примере нам смещение не требуется.
     */
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    /*
     * Включаем атрибуты вершин
     */
    glEnableVertexAttribArray(0);
    /*
     * Мы закончили работу с буферами для наших треугольников. В этом примере у нас не так много объектов для рисования, поэтому
     * мы ограничились тремя буферами. Чтобы случайно не испортить только что сделанную конфигурацию для указателя буфера VBO, мы
     * должны вызвать glBindBuffer c 0 во втором аргументе. Так мы гарантируем, что последующие функции для работы с буферами
     * не будут направлены ни на один из существующих.
     */
    glBindBuffer(GL_ARRAY_BUFFER, 0); 

    /*
     * ВАЖНО:
     * Никогда не вызывайте функцию 
     *        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)
     * если в данный момент остается активным один из VAO буферов, с которым EBO связан, потому что некоторые операций над буферами EBO делаются неявно.
     */

    /*
     * Хоть это и не обязательно, так как предполагается, что во время рисования буферы не инициализируются, мы отменяем действие
     * glBindVertexArray для последнего VAO, который был привязан. Это нас страхует от случайного его редактирования после
     * выхода из этой функции.
     */
    glBindVertexArray(0); 
}    
    
void Triangles::gRender(bool auto_redraw) {
    /*
     * Очередной этап обновления экрана
     */
    // заливаем фон следующим цветом
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    
    // Следующая команда говорит как рисовать примитивы: заливать их цветом или рисовать только каркас.
    switch (mode) {
        case 1:
            // будет рисоваться только каркас
            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
            break;
        case 0:
        default:
            // на обеих гранях полигона будет применена заливка цветом
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    }
    
    // вызываем шейдеры
    glUseProgram(shaderProgram);
    /*
     * В этой точке мы говорим, что должно быть нарисовано на сцене, т.е. где брать данные конвейеру.
     * Так как у нас всего один VAO нам не нужно делать его привязку к сцене каждый раз, но так программа
     * получается более структурированной.
     * 
     * В реальных проектах вы увидите, что в разные моменты временеи могут быть привязаны к сцене различные
     * VAO, в зависимости от логики вашей программы.
     */
    glBindVertexArray(VAO);
    switch(switcher)
    {
        case 1:
            // эта функция завставляет рисовать из буфера вершин VBO
            glDrawArrays(GL_TRIANGLES, 0, 3);
            break;
        case 2:
            glDrawArrays(GL_TRIANGLES, 1, 3);
            break;
        case 3:
            glDrawArrays(GL_TRIANGLES, 2, 3);
            break;
        case 0:
        default:
            // эта функция заставляет OpenGL рисовать из буфера индексов EBO
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
        
    }
    // glBindVertexArray(0); // ВАЖНО: Привязку VAO буфера не нужно снимать каждый раз - эта строка вообще говоря лишняя.
    
    // В базовой реализации производится вызов смены фонового и заднего буферов сцены при двойной буферизации и вызов
    // обработчиков для накопившихся сообщений
    base::gRender(auto_redraw);
    /*
     * Наша сцена полностью нарисована на экране. Теперь программа отображения снова повториться с самого начала.
     */
}

void Triangles::onKey(int key, int scancode, int action, int mods) {
    if (key == GLFW_KEY_1 && action == GLFW_PRESS)
        switcher = 0;
    else if (key == GLFW_KEY_2 && action == GLFW_PRESS) 
        switcher = 1;
    else if (key == GLFW_KEY_3 && action == GLFW_PRESS) 
        switcher = 2;
    else if (key == GLFW_KEY_4 && action == GLFW_PRESS) 
        switcher = 3;
    else if (key == GLFW_KEY_8 && action == GLFW_PRESS) 
        mode = 1;
    else if (key == GLFW_KEY_9 && action == GLFW_PRESS) 
        mode = 0;
}

void Triangles::gFinalize() {
    
    // освобождаем буферы 
    /*
     * Наш финализатор вызывается при выходе из основной программы. Возьмите за правило
     * очищать за собой все занятые вами буферы явно.
     */
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteBuffers(1, &EBO);
    
    base::gFinalize();
}

/*
 * Резюме
 * ------------
 * Программы визуализации, написанные с помощью OpenGL, имеют не замысловатую организацию, которая состоит из этапа
 * инициализации сцены, основного цикла рисования и финализатора. Конечно, ресурсы графической карты тоже ограничены
 * и если вы имеете большое количество графики, вы, вероятно, не сможете выгрузить ее целиком, потому что банально вам не хватит памяти и вам придется придумывать
 * алгоритмы постепенной подгрузки графики, когда наблюдатель будет собираться перекинуть на нее свой взор, и выгрузки
 * той части графики, графический вывод которой вероятно больше не понадобится.
 * 
 * Тем не менее, самый простой паттерн отображения имеет следующий вид (не считая шейдеры)
 * 
 * ...
 * // 1. Подготовка вершин и буферов для их размещения
 * float object_1[] = Item::set(myObject_1);
 * float object_2[] = Item::set(myObject_2);
 * ...
 * // 2. Подготовка VAOs
 * unsigned int VAOs[2];
 * unsigned int VBOs[2];
 * // вызов функций генерации буферов
 * ...
 * // подготовка данных
 * glBindVertexArray(VAOs[0]);
 * glBindBuffer(GL_ARRAY_BUFFER,VBOs[0]);
 * glBufferData(...);
 * // 3. Подготовка указателя для обработки вершин
 * glVertexAttribPointer(...);
 * glEnableVertexAttribArray(0);
 * 
 * [...] // повторяем процедуру для n-го числа буферов в зависимости от логики и возможностей аппаратной части
 * 
 * // Основной цикл
 * // 4. Рисуем сцену
 * // вызовы функций OpenGL, которые реконфигурируют конвейер.
 * glUseProgram(...);   // подгрузка шейдеров
 * glBindVertexArray(VAO[0]);
 * // рисуем объект из VAO[0]
 * glDrawArrays(...);
 * // рисуем объект из VAO[1]
 * glBindVertexArray(VAO[1]);
 * glDrawArrays(...);
 * ...
 * 
 * Вы управляете графикой через применение нужных вам шейдеров; вы можете
 * добиться реалистичного трехмерного отображения меняя перспективу, накладывая текстуры или используя эффекты, "играя" с цветом и тенью. Такое многообразие
 * вариантов визуализации, делает программирование графики необычайно интересным и сложным занятием.
 * 
 * Тем не менее, вы должны сначала понять с чего все начинается.
 */